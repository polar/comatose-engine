= Comatose Engine

This project rocks and uses MIT-LICENSE.

This project gem contains a small mountable Rails 3 Engine that provides some HTML content management
support that may be embedded into other Rails applications. At the time of this writing, this
project was developed with Rails 3.2.8 and Ruby 1.9.3-p194. There will be no support below that.
Other dependencies are in the +gemspec+ and +Gemfile+ files.

== Usage

Install the Gem.

   gem install comatose_engine, :git => "git://github.com/polar/comatose-engine", :branch => "rails3"

=== Migrate your data base (ActiveRecord)

If you are using ActiveRecord for an Object Relational Model (ORM), you need to add a couple
tables to your database to house the pages. Generate the migration and then run it.

   rake comatose:engine:install_migrations
   rake db:migrate

This process is standard Rails Engine stuff.

=== Mount the Engine

   Rails.application.routes.draw do
      root :to => "home/content#show"
      mount Comatose::Engine => "/home"
   end

== Example Application

The gem comes with a default example Rails application that should be able to get you up and running.
For instance, just with the engine mounted at +/home+ you can create pages, create content for them,
and reorder them.

==== Administer Pages

Start the standard rails server and point your browser to: http\://localhost:3000/home/pages
You will be able create pages and child pages that are accessed as:

  http://localhost:3000/home
  http://localhost:3000/home/sub-page1

and so on. The administration pages will assign "slugs" to your pages based
on the title you give the page. You may change the url slug for the page
at any time.

This project is a Rails Engine. It is meant to give you the processing capability for dynamic content
for pages that you may want to deploy in your application. The default application may not be
what you want, and in fact, I will dare say, it is probably not what you want.

So don't complain that there is no public configuration module for the application to jump through your hoops.
There also is no authentication or authorization model for it. If you want a configurable application, build one.
You may use pieces and parts of the default application. At the very least, they demonstrate how to use the controllers.

The +app/views/comatose/pages+ view is sufficiently pieced out in partial ERBs that you can pick and choose
what fields you want to show or not. The original Comatose had configuration options for hiding things.
I'll take it from here that you know how to deal with extending/mixing controllers
in engines. For instance, you may want to do extend/copy/modify the controllers if you want to add
authenticated authorization.

== Page Content (Liquid and Textile)

The body of a page is processed by ((<Liquid|URL:http://liquidmarkup.org>)) and (RedCloth's Textile|URL:http:http://redcloth.org/textile).
Liquid processes a page by giving you special constructs with which to program your page. Constructs
appearing between {% ... %} are control structures and do not print. Constructs
appearing inside {{ ...  }} are variable accesses and put forth their content.
Please check the Liquid documentation for more information and for the constructs available.

An example might be iterating through a page's children and listing their titles with
their page photos.

  <h1>This page has the following sub pages</h1>
  <dl>
  {% for p in page.children %}
     <dt>{{ forloop.index }}. {{ p.title }}</dt>
     <dd>|!{{ p.photo }}!:{{ p.url }}|</dd>
  {% endfor %}
  </dl>

In Comatose Engine, the variable {{ page }} refers to the page you are on. You may access
the children, content, title, slug, url, etc of any other page by using the "pages" variable.

  {{ pages['mary'].url }}

Note: You must be careful about how you name your pages. Just using a slug within
the [ ] brackets may result in a collection if you have more than one page with the same
slug. You may differentiate them by including the slug of the root page, prepended with a
hash (#) and using the full_path of the page. For instance, if you have two root pages with direct
child pages named "mary", you can differentiate them as:

  {{ pages['#fester/mary'].url }}

  {{ pages['#houser/mary'].url }}

For accessible page fields, see below.

=== Multiple Roots

You are allowed to have multiple root pages, and they are ordered. When accessing a page by
a full path url, and the page path matches two different pages from different roots,
the *first* root-page is used. So, assuming the "fester" root is before the "houser" root,
if you went to http\://localhost:3000/home/mary you would get to the "mary" page under the "fester" root.

Having multiple roots allows you to use roots that may be
hidden from user view. You can use extra roots to store snippets, which you can refer to by accessing
the body of them. If you had a root page called "snippet1", you could use:

  {{ pages["snippet1"].body }}

to include its contents. Remember, the "body" field returns exactly what you had in it. However, it will be
evaluated by Textile if you have Textile selected on the page in which you are including it.
There is no automatic escaping to make it look exactly like it was stored.

=== Variables

A Comatose::Variable is basically a Liquid::Drop, which means you define a variable for use within a
{{ ... }} construct. You may define a Comatose::Variable by a block, usually in an initializer, as follows:

  Comatose::Variable.define("products") do
    Products.all
  end

The variable evaluation is dynamic. Each time you use it, the block will get evaluated.
You may want a static variable that gets evaluated only when it is initialized. For that you
use:

  Comatose::Variable.define_static("app-title") do
    Rails::Application.title
  end

You may define Comatose::Variables that have keys by returning a Hash, such that you may
access different fields of a variable.  For example, if you define a variable as follows:

  Comatose::Variable.define("hey") do
    { "hello" => "Hello World!", "good_bye" => "Goodbye World!" }
  end

you may access these elements in Liquid/Textile as:

  {{ hey.hello }}
  {{ hey.good_bye }}
  {{ hey['hello'] }}
  {{ hey["good_bye"] }}

If you need bona fide methods to be dynamically evaluated you may extend Comatose::Variable as such:

  class V < Comatose::Variable
    def hello
      "Hello at #{Time.now}"
    end
    def good_bye
      "Good-bye at #{Time.now}"
    end
  end
  Comatose.register_variable("hey", V.new())

In this case, you must register an instance of the class under a name that you want to use in your Textile using
+Comatose.register_variable+. You  refer to these fields in Liquid/Textile the same way as above, i.e. as if they were
keys.

You *cannot* hand a method any arguments from Textile as if it were a parameterized function.
In the Liquid implementation, access into variables is always by [ ], with +fetch+ with an integer,
or using +size+, +first+, and +last+ on collections. You may get somewhat creative by returning another
Comatose::Variable by overriding [ ] and +has_key?+, but I'll leave that to the experimenter.

=== Page Variable Fields

The page variable has the following fields:

[+title+] This field returns the title column of the page.

[+slug+] This field returns the slug column of the page.

[+full_path+] This field returns the url path of the page from the mount point.

[+url+] This field returns the url path of the page including the mount point.

[+link+] This field returns the url path of a Rails link to the page including the mount point, such as +/home/3422+.

[+photo+] This field returns a url for the associated photo.

[+position+] This field returns the position in its parent's child list, which is ordered.

[+prev+] This field returns the previous page in the parent's child list, at position - 1.

[+next+] This field returns the next page in the parent's child list, at position + 1.

[+content+] This field returns the HTML content of the page as rendered by its filter, i.e. Textile or not.

[+body+] This field returns the body of the page, which is exactly what you may have typed in. Remember it is still evaluated by the filter of the current page.

[+children+] This field returns a collection of "page" that may be iterated through using a {% for .... %} construct.

==== Pages Variable

The +pages+ variable refers to other pages by their slugs or full paths. It has the following
formats:

  {{ pages['/path/to/page'] }}

This selection refers to a page by the full path. If the path belongs to 2 or more pages, a
collection will be returned, which may be iterated or selected with [0],[1], etc.

  {{ pages['#root/path/to/page'] }}

This selection refers to a page from the full path of a specific root.

  {{ pages['slug'] }}

This selection returns all pages with this particular slug.

== Multiple Engine Mounts

You may mount the engine many times just using Rails routes. For example, the following illustrates multiple mounts:

   Rails.application.routes.draw do
      root :to => "home/content#show"
      mount Comatose::Engine => "/home"

      mount Comatose::Engine => "/away"

      mount Comatose::Engine => "/:inbetween"
   end

The above Rails routes configuration mounts the engine at urls http\//localhost:3000/home, http\://localhost:3000/away,
and any other name, such as, http\://localhost:3000/syracuse, http\://localhost:3000/saranac-lake.


== Rants

I have many rants about Rails software and "magic".

This project is based on "Comatose: A Micro CMS" by Matt McCray.

I've embedded Comatose in a couple of systems, and that was not an effort for the light
hearted with Rails 2.3, engines plugin, dessert, etc.
In an effort to get something better in my next project, I gravitated toward
"Comfortable Mexican Sofa" (CMS) by Oleg Khabarov, probably because of Ryan's Railscast mention.

That project took a half ton truck, 100 cups of coffee, and an angry dog, and two weeks
to figure out WTF is going on.
Okay, maybe it was just me trying to fit it over MongoDB with MongoMapper, but I tore my bloody hair
out. It was way too complicated. Navigating the code was absolutely horrendous. And
what's with the damn configuration options? Geezus! They were just daunting. Furthermore, you didn't
know how they worked until you actually tried to do something with them that didn't work.
This crapola just lead to hours of debugging dynamic code. I have to thank the guys at Jetbrains for
RubyMine.  But with even great tools like RubyMine doesn't give you license to write crappy code.

It seems like since all this Ruby/Rails (stupid) "magic" exists, people feel they *must* use it!  CMS
was riddled with some of the most bizarre shit: before filters, after filters, methods overwriting
active record field accessors, all for what? To save on a variable name, a function definition, or just
to show people you're "smart"?

So, stop it people, just stop it!
Get off the meth, and get back to writing good, readable, understandable code. For example, I don't know
WTF happened, but in my days "DRY" stood for something you did when you got out of the water. "Don't
repeat yourself"? Really? I mean. really? WTF? You mean, we should now all write small functions,
modularize code, and then put it together in a coherent fashion and actually THINK about the problem
a bit before jamming it together? Really? We've got to come up with an acronym and make it a fad to
get us to do that? What the hell have they been teaching in college these days?

Listen, if you are buidling a system that "magic" shit just makes understanding a
system almost impossible without a lot of time invested (wasted, IMHO). What a crock!
After the debacle with Comfortable Mexican Sofa, I've decided to return to Comatose and something
simple. Even it was too complicated.

With the advent of Rails Engines, I've completely stripped Comatose down to its bare essentials
and eliminated all configuration options, and options of any kind, page caching, and other bells and
whistles. I added PaperClip and the ability to associate a photo with the page, because I needed
that functionality. Thinking about it, I may rip that out too.

So, if you want to use this stuff, you should be a good programmer, and you should know how to
modify/extend things. It is my hope so that they will work they way you want it to, without
having some obscure configuration option, or a covertly modified class crawling up
your butt and doing spins for 2 days.

I don't see the need to supply a default application for Comatose or to make it work out of the
box, but it was needed for testing, so there you have it. The real reason for it, is that
I couldn't test multiple engine mount points because the standard testing harness doesn't
know how to deal with that correctly yet. Named route methods are the culprit on that one. They only
refer to the last engine mounted. This situation is as of Rails 3.2.8.

Be warned, I make no claims for the
default app or wish to maintain it to a deployable status. Use it at your peril.
It serves merely as an example.

=== Contributing

If you want to improve upon this project, you can join the obvious Github party, i.e. fork it, and
send pull requests. But let me give you this warning:

If your pull request contains some "magic" use of a before_filter, after_filter *anywhere*,
or inserts improperly named methods, or replaces standard methods, into standard system classes, or
uses "responds_to?", it will be denied. Use of "method_missing" anywhere will get you duct taped
to a rocket and fired into the virtual abyss to go meet the Flying Spaghetti Monster.

And while your at it. Keep any comments up to date, in proper English, with correct spelling and
punctuation! Happy Coding! :)

Cheers,

Dr. Polar